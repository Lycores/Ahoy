## 小技巧

### 如何事件传参

柯里化，高级函数

### 如何避开CORS

setUpProxy

### 当父组件有事件需要获得子组件节点，但是子组件无法使用 ref 怎么办？

使用 forwardRef （这里可以继续展开）

### 传参方式

可以用state from location, useLocation hooks

## 遇到的问题

#### 我在做折叠卡片的时候，因为要watch很多卡片的状态，那么对应的事件函数也很多，我使用工厂模式放到一个函数里，用switch 分割，但还是太多，于是我想到使用新syntax，就是Variable[string]的方式，工厂模式的时候传入的string不再用在switch上，而是直接通过拼接成为object key 或者parameter. 这里遇到一个问题就是，我看到一些文章说，object key和它的string格式是等价的，其实不等价，他们打印出来一样但其实不一样，所以如果一个string想要当key,需要加[]成为[Computed property names](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#computed_property_names)

Play with Spotify API 的问题，因为是async请求，导致有些东西是空的，比如页面加载会自动请求，但是里面的attributes却是空的，因为attributes还没从服务器返回，比如说access_token

## 粗心的问题

大量比较粗心的问题暴露在api 调试上，打个比方，我先做了getsavedalbum这个功能，我发现它返回的json有完整的track信息，我一开始在请求让player播放的时候一直失败，后来我发现有一个叫position的信息是需要填的（但是API文档没有重点标识），这个postion指的是track在album中的index,所以想要给出track id让player播放是一件不可能的事情。后来我做了getTopTrack这个功能，但是getTopTrack这个功能返回的track没有他在album中的position这个信息，我想完了，我要请求十次album的信息才行。但是我如果连续async请求十次，服务器直接把我当ddos攻击了，后来我找到一个api，是一次请求获得多个album。不过后来我又发现，track里有一个叫track number的东西，它就是position，但是我怎么试服务器都给403，我最后发现的原因是，position是0开头，track number是1开头，我误以为track number也是0开头的，然后我测试的track正好是专辑的最后一张这导致我给服务器的position一直是out of range

player button onClick 直接叫了函数没有给函数指针，导致back, next, pause 在来回换，因为他们都被call了。音乐卡死了



## 设计模式

##### 首先在主页的卡片我们要追踪很多很多的卡片，那就有很多state需要更新，那就要放置很多的clickHandler, 那就有很多function。首先我们通过工厂模式集中更新state. 但是我发现使用简单的工厂模式依然有很长的switch, 后来我追加了一个工厂模式，通过 拼接注入的名字和某个字符串生成object的key，再使用es6 syntax computed property names, 使用一个function就替代了超长的代码



## 设计经验

（存疑）CSS layout设计应该以谁最重要，谁定义谁的尺寸就应该先被编写CSS。这是一种自下而上的设计。比如我想定义一个音乐播放器，而上方是一些playlist，他们竖直放在一个container里，我要求它在某个尺寸以下变为fixed的小播放器，这个时候player拥有更高的优先级。它应该先被定义。也就是说，player的尺寸先于container的尺寸被设计， 说到底，就是是先设计小部件的尺寸，再让宽高自己适应，还是先设计宽高，再设计小部件

设计的时候要避免watch 不必要的 state, 比如，onclick的时候，如果发生对象和作用对象一致，不需要用useRef， 直接event.target就可以。有时候为了方便调整layout我通常会设计很多global变量，做到修改一处代码整个layout修改。这个，与 responsive page是不同的，只有当尺寸改变需要相应才需要useState



## 路程

一开始只是想制作一个home assistance， 做完了card的transition之后我的野心变大了，想要做一个music player 带响应式的， 所以制作了top bar并且达到了响应式，然后开始制作playlist 页面在成功让spotify在我的页面运行之后我就觉得这个更像一个音乐播放器. 而且以前的home assistance感觉开始有点无聊 所以我在想怎么运用卡片这个废弃资产.在开发了album和artist页面后，我发现album page和artist page在左侧的重合率太高了，所以我一想这不就是navbar吗，所以我把左侧component独立出来然后用nested router 和outlet只刷新右侧，这让player的状态贯穿所有页面，player每次刷新都需要重新加载j s 重新请求device id,这样独立出来就不会被刷新。然后呢我发现很多组件很没必要地刷新，我想要usememo解决这个问题

然后呢我又发现nexted component太多了，一个token要穿越五六层component,可以考虑

## 优化：

在设计响应式页面我制作了大量的global length 来确保每个部件行为一致，同样的，即使部分代码使用css我也希望提高复用性，所以我引入sass

然后我开始发现页面有些卡了，之前都是用display none的，不能用了，我用 react router按需要加载

后来发现使用route的话，左侧的player会不停地加载，因为这个事从spotify网站动态插入code的，也就是每次player组件加载，就会请求player对象。所以我把整个左侧栏全部变成navBar, 利用react router的组件式路由特性，把navBar 隔离在路由之外



## Spotify 的OAuth是如何工作的

## 优化需求



album页面和其他页面有一些不同， 因为得到的album object拥有完整的track信息，所以我不再需要进行请求，

artist页面需要进行请求

flex布局的时候没有设置grow属性导致页面即使只有两个元素也无法横向充满，只能保持子元素填充的宽度，宽度失效

只用css制作responsive的正方形很难，需要用js

z-index的知识点

错误:想要播放音乐需要position才可以

细节：Searcher 强制取消聚焦

确保deviceId准备好了再渲染

问题发现，每次刷新的时候都会重新请求deviceId,超级多的请求 而且用户不停切换的时候太快导致请求的新的device_id还没到，那就无法播放会出错



## HighLight: 

stop player refresh

fully responsive



遇到的问题，我发现album page和artist page在左侧的重合率太高了，所以我一想这不就是navbar吗，所以我把左侧component独立出来然后用nested router 和outlet只刷新右侧，这让player的状态贯穿所有页面，player每次刷新都需要重新加载j s 重新请求device id, 遇到的问题，因为是nested url,打个比方以前是/album /artist, 现在要先进入/traditional 装配左侧组件，再根据右侧router装配，所以是/traditional/album 这样，我需要把大量的共用代码拆分放到/traditional对应的组件里面，在这个时候，我没意识到我的proxy和server也要加/traditional，所以花了很多时间在上面.同时，有的请求是在/下请求的就不需要/traditional

然后我发现一直使用props太烦了，所以我使用recoil

状态控制，传播与async函数的问题： 我们要让useEffect只在必要的时候运行，同时setState保证一要在必要的时候重新渲染。打个比方我们有很多个async函数，。。。

不同的写法对比，如果用async/await写法，变量值会以null先返回，如果在.then()中等待可能更好

大坑： setState不更新的原因：例子，我有一个array是async得来的album： 渲染不会等待数组我承认，我准备了default case, 然后我发现，得到数组之后update,居然，不rerender, 后来我发现，setstate只是欠监听，要变化被发现，需要用三点表达式

需要的思考？我使用react.memo用来防止重复的渲染，但是我又觉得数据流太长了，我想要recoil，但是recoil破坏了props， 那么react.memo就无效了，我得选出一个东西来决定这个渲染是否是是无效的，其他的东西放入recoil

## Optimization: 

困难： recoil和react.memo的冲突

验证这件事放到welcome page 去

还有一些其他需要考虑的地方，打个比方我在‘/’页面就开始向服务器请求数据了，但是万一一直不点，就超时了

所以需要移动到welcome page等待按下按钮再去fetch安全一点

出现问题: 我想要去渲染一个音乐列表但是列表就是渲染不出来虽然数据对的。原因就是async拿到数据之前就渲染了，然后拿到数据之后没有重新渲染，导致列表一直是空的

setState和 useEffect的想法，如果有有一个列表需要一秒渲染。渲染后我拿到值，那我是不是要再次setState,那我会再次去拿值，再次重新渲染无限循环

如何理解不要再渲染的时候setstate?



i need to write something

文字排版上遇到的困难。

从css in js迁移到 styled component

确保宽度高度在一个ratio 同时还是dynamically scaled

recoil无法在刷新的时候继续保持state

尝试使用HOC，但是HOC无法应用于函数式组件，报错和hook有关，我看了网上很多资料，都是用类式组件



小知识：如果你在一个then函数里先 let a = xxx.json(), 再console.log(a) 对不起，a依然是promise, 你需要在下一个then里作这件事



搜索框：搜索框混用了setTimeout和abortcontroller, 目的在于改进abortcontroller的问题。原来的想法是，当用户不断on change，我不断abort之前的request，但是问题在于这给了服务器更大的压力，所以我使用了useTimeout和abortcontroller结合，在一段时间之后再abort之前的request再发送，这也有助于abort request 在一个非常极端的网络环境下





如何实现search page top result功能。flex-grow都为1， 

在flex换行前通常我们要求两个元素有空隙，在换行后我们又要求这个空隙的css消失。最好的办法不是使用margin而是对flex父元素使用gap

flex时候设置自动换行，下面有东西拒绝换行怎么办



响应式里最难的是什么？最难的是用flex/grid的情况下进行一个好的响应式体验。假设我用flex去均分一个宽度，那么各个元素是不知道自己的宽度的，如果在某个元素里有需要使用overflow scroll的东西的时候就蒙了，父元素的宽度是flex决定的，而父元素的最小宽度是子元素的最小宽度，也就是说父元素无法小于子元素，没有scrollbar出现



## 最大的困难：

##### 结论：最大的困难就是在flex布局下的智能sizing，智能typography的同时保证不出现任何overflow的同时让页面看起来好看。

##### 阶段1: 问题的发现：（视频）如图，左封面和右边的text都属于flex item，左边的封面是由clamp(px, vw, px）定义的)， 右边的font-size同样是由 clamp(px, vw, px)定义的。问题在于，一开始画面的content没有overflow,之后就overflow了，为什么？

##### 阶段1: 问题的解答：如果不显性表达，flex item的width是失效的的。打个比方，我们都知道overflow发生的条件是父元素宽度比子元素低，假设这个情况，如果父元素是flex的item，并且这个父元素有一个子元素，子元素是固定的宽度，我们希望通过减小窗口宽度来减小父元素的宽度从而让子元素宽度大于父元素，这是不可能实现的，整个页面会overflow而不是父元素overflow,因为父元素的宽度的最小值是子元素的宽度，overflow永远不会发生。如果我们希望而在响应式里面显性表达宽度意味着要一直使用JS进行计算并且重复渲染。flex item的width完全由它孩子的宽度决定，然而在视频里，clamp是一个智能的css表达式，我们无法精确控制它的宽度，所以它孩子的宽度撑起父亲的宽度，当我们继续减少window width,自然会出现content overflow

##### 阶段2: 问题的发现: 当我发现使用CSS很难解决上述问题的时候，我决定使用JS去解决这个问题，我使用减法获得text可以伸展的最大宽度并且应用在style上，然而我发现了另一个问题：cover的尺寸不动了

##### 阶段2: 问题的解答：cover的尺寸不动的原因是因为我们一直维护着text的宽度， clamp感受不到压力就不会减少width,也就是说，想要让cover 的宽度动态变化只用js是行不通的。

##### 阶段3: 问题的发现: 可以发现，一开始clamp的工作是很好的然而它的表现越来越糟糕，其中有两个原因：第一个原因是作为cover，我们不能让它的尺寸变得很小，所以cover的变化有限，限制了text的空间。第二是左侧的navbar的尺寸是不变的，所以天然上的讲，text的空闲宽度也会越来越小。

##### 阶段3: 问题的解答：为了应对这个问题我决定设置一个breakpoint, 当cover尺寸小于breakpoint的时候，JS才开始介入, 这样做的好处在于，当text很长的时候，这个时候图片size的state处于 和vw成比例的状态，也就是持续缩小，同时text的width被js控制也在缩小。当text很短的时候，我们就晚点使用js操控,clamp这个时候完全够用。同时我做了一系列优化，比如当text很长的时候稍微减小font-size，页面responsive的情况变得可以接受了（视频）同时这个页面也需要关注下如果下方的track名字太长需要对text进行overflow



